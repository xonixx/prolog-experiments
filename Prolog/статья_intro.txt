
Пролог, введение.

Чтобы заинтересовать читателя и облегчить ему начало работы с прологом я решил написать немного из начальных данных (?) о прологе.
Кратко основные особенности пролога.
Типы данных

Числа

?- A = 12, B = -0.5e4.
A = 12,
B = -5000.0.

Сразу нужно сделать важную оговорку. Все "переменные" (хотя, пожалуй, в прологе не следует применять это слово, а лучше сказать "неизвестые") обозначаются с большой буквы.

Атомы

 ?- A = abc, B = 'Hello World'.
A = abc,
B = 'Hello World'.

Строки

?- S = "Привет мир".
S = [1055, 1088, 1080, 1074, 1077, 1090, 32, 1084, 1080|...].

Видно, что строки являются списками кодов символов, т.е. к ним применимы все те же операции что и к спискам, но об этом позже.

Списки

?- A=[], B=[a, bbb, 123, "Привет", A], C=[A,B].
A = [],
B = [a, bbb, 123, [1055, 1088, 1080, 1074, 1077|...], []],
C = [[], [a, bbb, 123, [1055, 1088, 1080|...], []]].

Видим, что списки
1) могут быть разнородными (содержать любые комбинации вышеперечисленных типов)
2) могут быть вложенными

Функторы

12 ?- A = aaa(bbb, ccc, [12, 13], 123.4e34), B = bbb(cc, A), C=cc(1, C).
A = aaa(bbb, ccc, [12, 13], 1.234e+036),
B = bbb(cc, aaa(bbb, ccc, [12, 13], 1.234e+036)),
C = cc(1, **).

13 ?- C=cc(1, C), cc(1, cc(1, B))=C, C=B. % совпадают
C = cc(1, **),
B = cc(1, **).

Функторы - это, грубо говоря, структуры (... ?). Как видим, могут тоже быть вложенными.
Последний запрос может быть не совсем понятен, но должен стать понятен в процессе прочтения статьи.

Заметим, что между этими типами существует глубокая связь, например, списки есть ни что иное, как более красивое (синтаксический сахар) обозначение функтора "."

?- A = (.(1,.(2, .(aa, .(bbb, []))))).
A = [1, 2, aa, bbb].

Забегая на перед скажем, что так можно разбивать список на голову и хвост

 ?- [a,b,c,d] = (.(H, T)).
H = a,
T = [b, c, d].

Хотя так никто не делает, в виду того, что для конструирования списков из головы и хвоста (а также обратное преобразование, т.е. разделение списка на голову и хвост) есть более удобный синтаксис вида [H | T]

22 ?- [a,b,c,d] = [H | T].
H = a,
T = [b, c, d].

25 ?- Head = голова, Tail = [о, с, т, а, л, ь, н, о, е], List = [Head | Tail].
Head = голова,
Tail = [о, с, т, а, л, ь, н, о, е],
List = [голова, о, с, т, а, л, ь, н, о|...].

26 ?- A = [a | [ b | [ c | [d | [] ] ] ] ]. % напоминает hasskell, не так ли? )
A = [a, b, c, d].

27 ?- [A,B,C | Tail] = [1,2,3,4,5,6].
A = 1,
B = 2,
C = 3,
Tail = [4, 5, 6].

В равнозначности синтаксисов можно убедиться запросом

?- [H | T] = (.(H, T)).
true.
% т.е. справедливо при любых значениях неизвестных H и T.

Как видим, тут проявляется на первый взгляд не совсем привычное поведение знака =, а именно то, что он работает "в обе стороны". И это очень важный момент. Дело в том, что в прологе
знак = обозначает не обычное императивное равенство, а унификацию, а именно сопоставление левой и правой части и в случае удачного сопоставления конкретизация неизвестных значений.
Фраза может выглядеть немного заумно, легче пояснить на примере.

28 ?- aaa = bb. 
false. % сопоставление неудачно (атомы не совпадают)

29 ?- aaa = aaa.
true. % удачно

30 ?- aaa(bbb) = aaa(bbb).
true. % удачно (функторы совпадают)

31 ?- aaa(bbb) = aaa(B).
B = bbb. % удачно + выполнена конкретизация

32 ?- aaa(bbb) = aaa(B, C).
false. % не удачно, арность (число параметров) функторов не совпадает

33 ?- aaa(bbb, C) = aaa(B, ccc(1)).
C = ccc(1),
B = bbb.
% удачно + конкретизация

34 ?- [1,2] = [1,2,3,4].
false. % списки не совпадают

35 ?- [1,2 | T] = [1,B,3,4].
T = [3, 4],
B = 2.
% удачно + конкретизация

Разобравшись немного с понятием унификации, стает понятно, почему

?- A = 2, A = 5.
false.

Выполнив первую унификацию, пролог система сопоставляет неизвестную A c числом 2. Таким образом вторая унификация будет ни что иное как 2 = 5, т.е. сопоставление чисел 2 и 5 которое конечно же окончится неудачей
в виду того что числа не равны.
Чтобы точно уяснить смысл последнего запроса, нужно еще пояснить смысл функтора ",". Да, не удивляйтесь, "," это действительно функтор (а именно, инфиксный оператор с арностью 2) и последнее выражение может быть записано в виде

47 ?- C=..[(,),A=2,A=5], C.
false.

а вот

48 ?- C=..[(,),A=2,A=B], C.
C = (2=2, 2=2),
A = 2,
B = 2.

что эквивалентно

 ?- A = 2, A = B.
A = 2,
B = 2.

Впрочем, не отчаивайтесь, если Вам не понятны последние 2 запроса )
Однако, мы отвеклись. Оператор "," обозначает ни что иное, как логическое "И". Понятно что если мы говорим системе что некоторое число равно 2 _и_ (при этом) оно же равно 5 то мы очевидно врем, о чем система нам и сообщает. Для логического "ИЛИ" предусмотрен оператор ";".

 ?- A = 2; A = 5.
A = 2 ;
A = 5.

Собственно, ответ системы не представляет ничего удивительного. Она ответила ровно то, что мы ей сообщили, а именно, что неизвестное число это либо 2 либо 5.

Впрочем если мы конкретизируем наш запрос (неизвестное число это либо 2 либо 5 и при этом оно четное), то и ответ системы обретет однозначность

?- (A = 2; A = 5), A mod 2 =:= 0.
A = 2 ;
false.

Наблюдательные могут спросить, что же тогда есть false в конце - неужели унификация не удалась? Тут мы подошли ко второй особенности языка пролог, не свойственной больше почти никакому другому языку программирования (кроме Mercury =) ), а именно backtracking или если сказать по русски - поиск с возвратом (?). Конкретно для последнего примера система рассуждает следующим образом - допустим A=2 проведем проверку на A mod 2 =:= 0 - выполняется, сопоставление удачно - выполняется конкретизация (A=2), далее происходит откат (возврат) к первой части утверждения и проверяется гипотеза A = 5, она терпит крах и потому система показывает false.
Забегая на перед, замечу, что можно отменить возврат (после первого удачного сопоставления) с помощью оператора отсечения "!"

 ?- (A = 2; A = 5), A mod 2 =:= 0, !.
A = 2.
% ответ системы однозначен

Попробуем выполнить арифметическое вычисление. 
 ?- A = 2 + 3 * 5.
A = 2+3*5.

тут нас ожидает конфуз. Оказывается, система воспринимает арифметические операции как обычную комбинацию функторов. Действительно, запрос 
 ?- A + B * C = (+(A, *(B, C))).
true.

показывает что так и есть. Что же тогда делать? Но оказывается, есть специальный предикат is/2 (через "/" обычно обозначается арность предиката), который выполняет арифметическое действие.

 ?- A = 2 + 3 * 5, B is A.
A = 2+3*5,
B = 17.

Пока что мы работали в интерактивном режиме, чтобы "пощупать" пролог на вкус. Обычно же, пролог-программы, как и программы на любом другом языке представляют собой файл с текстом программы. Обычной практикой является загрузка этого файла в интерактивную среду с помощью команды consult('file'). (или ее синтаксическим сахаром - [file].) и последующими запросами к программе, т.е. к фактам и предикатам в ней определенным.
Пролог машина, используя описанные выше 2 основных механизма (унификация с конкретизацией + backtracking) вычисляет необходимый результат.

Программа на прологе представляет собой обычно совокупность фактов и предикатов. Подробнее об этих понятиях. 
Факт есть некоторое отношение, а точнее сказать экземпляр такого отношения, например

% набор из 4 фактов, представляющих отношение "мальчик", применимое к одному параметру (имени мальчика, заданному в данном случае атомом)
boy(tom).
boy(pit).
boy(buzz).
boy(john).

% --//-- отношение "девочка" --//--
girl(ann).
girl(jill).
girl(kate).
girl(emily).

% набор из фактов, выражающих отношение "любит" между двумя субъектами
% (в смысле "первый любит второго")
loves(tom, jill).
loves(jill, buzz).
loves(jill, ann).
loves(pit, ann).
loves(ann, pit).
loves(buzz, pit).
loves(kate, kate).

Предикаты же, это отношения, которые сопровождаются некоторыми дополнительными условиями (что-то вроде: "отношение справедливо, если выполнены след. условия ..."). Эти самые условия записываются через оператор ":-" . Напишем несколько предикатов для нашей базы фактов.

% влюбленные люди
in_love(X) :-
	loves(X, _). % X в кого-то влюблен

% те, в кого влюблены
is_loved(X) :-
	loves(_, X). % кто-то влюблен в X

% взаимная любовь
mutual_love(X) :-
	loves(X, Y), % некто любит кого-то
	loves(Y, X). % а этот кто-то любит его(её).

% безответная любовь
answerless_love(X) :-
	loves(X, Y), % --//--
	\+ loves(Y, X). % a этот кто-то - нет.


Введем немного нетолерантный предикат, определяющий принадлежность к ориентации =)

% гомо
orient(X, gomo) :-
	(   boy(X), loves(X, Y), boy(Y) % мальчик любит мальчика или
	;   girl(X), loves(X, Y), girl(Y) % девочка любит девочку
	), X \= Y. % и это не один и тот-же человек

% гетеро	
orient(X, getero) :-
	(   boy(X), loves(X, Y), girl(Y) % мальчик любит девочку или
	;   girl(X), loves(X, Y), boy(Y) % наоборот
	), X \= Y. % --//--

% би
orient(X, bi) :-
	orient(X, gomo), 
	orient(X, getero).

% Oo
orient(X, narciss) :- 
	loves(X, X). % любит сам себя Oo


Полезно заметить, что факт - это фактически тоже разновидность предиката, более того вышеприведенные 4 факта boy(...) могут быть записаны одним предикатом

boy(B) :-
	B = ann; B = tom; B = buzz; B = john.

или даже

boy(B) :-
	member(B, [ann, tom, buzz, john]).

но все же из соображений выразительности следует применять факты там где это логично.

Запросы к системе

16 ?- in_love(tom).
true. % да

17 ?- in_love(burry).
false. % нельзя ответить, т.к. burry системе не известен

18 ?- in_love(Who). % перечислить влюбленных
Who = tom ;
Who = jill ;
Who = pit ;
Who = ann ;
Who = buzz ;
Who = kate.

19 ?- is_loved(ann).
true ; % да
false.

20 ?- is_loved(john).
false.

21 ?- is_loved(Who). % перечислить тех, кого любят
Who = jill ;
Who = buzz ;
Who = ann ;
Who = pit ;
Who = pit ;
Who = kate.

22 ?- \+ in_love(Who), \+ is_loved(Who). % вопрос на смекалку - почему это не работает, а работает след. запрос?
false. 

23 ?- (boy(Who); girl(Who)), \+ in_love(Who), \+ is_loved(Who). % все кто не любят и не любимы
Who = john ;
Who = emily.

24 ?- mutual_love(Who). % у кого есть взаимная любовь
Who = pit ;
Who = ann ;
Who = kate. % хи-хи, ну формально, да

25 ?- answerless_love(Who). % а у кого ее нет
Who = tom ;
Who = jill ;
Who = buzz ;
false.

33 ?- orient(Who, getero). % традиционная ориентация
Who = tom ;
Who = pit ;
Who = ann ;
Who = jill ;
false.

36 ?- orient(kate, Orient).
Orient = narciss.

37 ?- orient(buzz, gomo), !.
true. % гей

39 ?- orient(Who, gomo), boy(Who). % геи
Who = buzz ;
false.

40 ?- orient(Who, gomo), girl(Who). % лесби
Who = jill ;
false.

42 ?- orient(X, bi).
X = jill ;
false.

...

Чтобы подытожить, можно отметить что программа на прологе представляет собой одновременно базу данных (не реляционную, конечно, но допускающую практически любую функциональную зависимость) (факты) и инфраструктуру запросов к этой базе данных (предикаты), позволяющую построить по данным из базы данных новые отношения, зависимости, или получить некий результат, связанный с данными. (Впрочем, факты могут и отсутствовать)
При этом сами запросы (предикаты) способны иметь довольно замысловатую логику или даже выполнять вычислительные задачи. Чтобы окончательно повергнуть читателя, добавим, что предикаты способны динамически порождать факты и даже другие предикаты. Отличие от, вероятно, знакомой читателю императивной парадигмы программирования - в декларативной сущности получаемых программ.
Обратная сторона подобной гибкости концепции, разумеется, скорость (о чем справедливо указывали коментаторы предыдущего поста по прологу, впрочем коммерческие реализации пролога обладают довольно недурной производительностью). 
Однако соблазнительная сторона такого подхода - возможность чрезвычайно выразительного (пусть, возможно, и не быстрого) решения на прологе задач символьных вычислений, парсинга текста и сложных структур данных (в т.ч. по грамматикам), задачах поиска, экспертных системах, задачах искуственного интеллекта. 

Java - Refal - Prolog

(...)

Вот решение этой задачи на прологе:

ischar(H, [H]).

% пустые строка соответстует пустому паттерну.
matches([], []) :-!.

% если равны первый знак патерна и строки, или первый знак паттерна "?"
% то для соответствия должны соответствовать "хвосты" строки и паттерна
matches([H | T], [H1 | T1]) :-
	(   
	H = H1;
	ischar(H, "?")
	),
	matches(T, T1), !.

matches([H | T], T1) :-
	ischar(H, "*"), % если первая буква паттерна * то
	append(_, T2, T1), % некая подстрока T2 хвоста строки T1 
	matches(T, T2), !. % должна соответствовать хвосту паттерна


и проверка (остальные опустил из-за того, что очень длинные строки не влезают в страницу сайта)

check:-
	matches("ASDFAASDASDAAASDASDASD", "ASDFAASDASDAAASDASDASD"),
	matches("*", "ASDFAASDASDAAASDASDASD"),
	matches("A?DF?A*ASD*ASDA?DASD", "ASDFAASDASDAAASDASDASD"),
	\+ matches("ASDFAASDADAAASDASDASD", "ASDFAASASDAAASDASDASD").

Запускаем проверку:

?- check.
true. % алгоритм работает верно на текстовых данных

Полный текст программы доступен [здесь].










