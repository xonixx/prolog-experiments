Довольно оживленное обсуждение предыдущей стати (<a title="http://habrahabr.ru/blogs/programming/47416/" href="http://habrahabr.ru/blogs/programming/47416/" id="l1l-">http://habrahabr.ru/blogs/programming/47416/</a>) показало, что тема пролога оказалась интересна сообществу.<br>
Чтобы заинтересовать еще более читателя и вместе с тем облегчить ему начало работы с этим языком, я решил написать немного начальных данных о прологе.<br>
<br>
Кратко основные особенности.<br>
<br>
Типы данных<br>
<br>
<i>Числа</i><br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 12, <font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> -0.5e4.<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 12,<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> -5000.0.<br>
<br>
?- <font color="blue"><b><b>number</b></b></font>($<font color="#808000"><i>A</i></font>), <font color="blue"><b><b>number</b></b></font>($<font color="#808000"><i>B</i></font>).<br>
<font color="blue"><b><b>true</b></b></font>. <font color="#909090"><i>% показываем, что тип переменных - числа<br></i></font>
</font></code></blockquote>
Сразу нужно сделать важную оговорку. Все переменные (неизвестные) обозначаются <i>с большой буквы</i>.<br>
<br>
<i>Атомы</i><br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <b>abc</b>, <font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> <font color="#008000">'Hello World'</font>.<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <b>abc</b>,<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> <font color="#008000">'Hello World'</font>.<br>
<br>
?- <font color="blue"><b><b>atom</b></b></font>($<font color="#808000"><i>A</i></font>), <font color="blue"><b><b>atom</b></b></font>($<font color="#808000"><i>B</i></font>).<br>
<font color="blue"><b><b>true</b></b></font>. <font color="#909090"><i>% показываем, что тип переменных - атомы<br></i></font>
</font></code></blockquote>
<i>Строки</i><br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>S</i></font> <font color="blue"><b>=</b></font> <font color="#008000"><b>"Привет мир"</b></font>.<br>
<font color="#808000"><i>S</i></font> <font color="blue"><b>=</b></font> [1055, 1088, 1080, 1074, 1077, 1090, 32, 1084, 1080|...].<br>
</font></code></blockquote>
Видно, что строки являются списками кодов символов, т.е. к ним применимы все те же операции что и к спискам, но об этом позже.<br>
<br>
<i>Списки</i><br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font><font color="blue"><b>=</b></font>[], <font color="#808000"><i>B</i></font><font color="blue"><b>=</b></font>[<b>a</b>, <b>foo</b>, 123, [[[[[1,2,42]],<b>bar</b>]]], <font color="#008000"><b>"Привет"</b></font>, <font color="#808000"><i>A</i></font>], <font color="#808000"><i>C</i></font><font color="blue"><b>=</b></font>[<font color="#808000"><i>A</i></font>,<font color="#808000"><i>B</i></font>].<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> [], <font color="#909090"><i>% пустой список<br></i></font>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> [<b>a</b>, <b>foo</b>, 123, [[[[[1|...]], <b>bar</b>]]], [1055, 1088, 1080, 1074|...], []],<br>
<font color="#808000"><i>C</i></font> <font color="blue"><b>=</b></font> [[], [<b>a</b>, <b>foo</b>, 123, [[[[...]|...]]], [1055, 1088|...], []]]<br>
</font></code></blockquote>
Видим, что списки<br>
1) могут быть разнородными (содержать любые комбинации выше- (и ниже-) перечисленных типов)<br>
2) могут быть вложенными<br>
<br>
<i>Структуры</i><br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <b>aaa</b>(<b>bb</b>), <font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> <b>aaa</b>(<b>bbbbbb</b>, 123, [456, <b>c</b>]), <font color="#808000"><i>C</i></font> <font color="blue"><b>=</b></font> <b>ccc</b>(<b>ddd</b>(<b>eee</b>), <b>fff</b>, <b>g</b>(<b>h</b>(<b>i</b>(<b>j</b>(<b>kkkkk</b>))))).<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <b>aaa</b>(<b>bb</b>),<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> <b>aaa</b>(<b>bbbbbb</b>, 123, [456, <b>c</b>]),<br>
<font color="#808000"><i>C</i></font> <font color="blue"><b>=</b></font> <b>ccc</b>(<b>ddd</b>(<b>eee</b>), <b>fff</b>, <b>g</b>(<b>h</b>(<b>i</b>(<b>j</b>(<b>kkkkk</b>)))))<br>
</font></code></blockquote>
Пример осмысленнее:<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>Family</i></font> <font color="blue"><b>=</b></font> <b>family</b>(<b>father</b>(<b>bill</b>, <b>age</b>(37)), <b>mother</b>(<b>ann</b>, <b>age</b>(34)), <b>children</b>([<b>son</b>(<b>john</b>, <b>age</b>(10)), <b>daughter</b>(<b>jill</b>, <b>age</b>(8))])).<br>
<font color="#808000"><i>Family</i></font> <font color="blue"><b>=</b></font> <b>family</b>(<b>father</b>(<b>bill</b>, <b>age</b>(37)), <b>mother</b>(<b>ann</b>, <b>age</b>(34)), <b>children</b>([<b>son</b>(<b>john</b>, <b>age</b>(10)), <b>daughter</b>(<b>jill</b>, <b>age</b>(8))]))<br>
<br></font></code></blockquote>
Примеры посложнее:<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <b>aaa</b>(<b>foo</b>, <b>bar</b>, <font color="#008000"><b>"абв"</b></font>, [12, 13], 123.4e34), <font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> <b>bbb</b>(<b>cc</b>, <font color="#808000"><i>A</i></font>, [<font color="#808000"><i>A</i></font>, <b>fff</b>(<font color="#808000"><i>A</i></font>)]), <font color="#808000"><i>C</i></font><font color="blue"><b>=</b></font><b>foo</b>(<b>foo</b>(<b>foo</b>(<b>foo</b>(<b>bar</b>)))), <font color="#808000"><i>D</i></font><font color="blue"><b>=</b></font>(+(2, *(3, -(7, 2)))).<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <b>aaa</b>(<b>foo</b>, <b>bar</b>, [1072, 1073, 1074], [12, 13], 1.234e+036),<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> <b>bbb</b>(<b>cc</b>, <b>aaa</b>(<b>foo</b>, <b>bar</b>, [1072, 1073, 1074], [12, 13], 1.234e+036), [<b>aaa</b>(<b>foo</b>, <b>bar</b>, [1072, 1073, 1074], [12, 13], 1.234e+036), <b>fff</b>(<b>aaa</b>(<b>foo</b>, <b>bar</b>, [1072, 1073, 1074], [12, 13], 1.234e+036))]),<br>
<font color="#808000"><i>C</i></font> <font color="blue"><b>=</b></font> <b>foo</b>(<b>foo</b>(<b>foo</b>(<b>foo</b>(<b>bar</b>)))),<br>
<font color="#808000"><i>D</i></font> <font color="blue"><b>=</b></font> 2+3* (7-2)<br>
<br>
?- <font color="#808000"><i>C</i></font><font color="blue"><b>=</b></font><b>cc</b>(1, <font color="#808000"><i>C</i></font>), <b>cc</b>(1, <b>cc</b>(1, <font color="#808000"><i>B</i></font>))<font color="blue"><b>=</b></font><font color="#808000"><i>C</i></font>, <font color="#808000"><i>C</i></font><font color="blue"><b>=</b></font><font color="#808000"><i>B</i></font>. <font color="#909090"><i>% <font color="#808000"><i>B</i></font> и С совпадают<br></i></font>
<font color="#808000"><i>C</i></font> <font color="blue"><b>=</b></font> <b>cc</b>(1, **), <font color="#909090"><i>% рекурсивная структура, с бесконечной вложенностью<br></i></font>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> <b>cc</b>(1, **).<br>
</font></code></blockquote>
Структура в прологе представляется функтором (имя структуры, то что до скобок) и параметрами (то что в скобках). Число параметров называется <i>арностью</i> функтора.&nbsp; <br>
Как видим, структуры тоже могут быть вложенными.<br>
Последний запрос может быть не совсем понятен, но должен стать понятен в процессе прочтения статьи.<br>
<br>
Заметим, что между этими типами существует глубокая связь, например, списки есть ни что иное, как более красивое (синтаксический сахар) применение функтора "."<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> (.(1,.(2, .(<b>aa</b>, .(<b>bbb</b>, []))))).<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> [1, 2, <b>aa</b>, <b>bbb</b>].<br>
</font></code></blockquote>
Забегая на перед скажем, что так можно разбивать список на голову и хвост<br>
<br><blockquote><code><font size="2" face="Courier New">
?- [<b>a</b>,<b>b</b>,<b>c</b>,<b>d</b>] <font color="blue"><b>=</b></font> (.(<font color="#808000"><i>H</i></font>, <font color="#808000"><i>T</i></font>)).<br>
<font color="#808000"><i>H</i></font> <font color="blue"><b>=</b></font> <b>a</b>,<br>
<font color="#808000"><i>T</i></font> <font color="blue"><b>=</b></font> [<b>b</b>, <b>c</b>, <b>d</b>].<br>
</font></code></blockquote>
Хотя так никто не делает, в виду того, что для конструирования списков из головы и хвоста (а также обратное преобразование, т.е. разделение списка на голову и хвост) есть более удобный синтаксис вида [H | T].<br>
<br><blockquote><code><font size="2" face="Courier New">
?- [<b>a</b>,<b>b</b>,<b>c</b>,<b>d</b>] <font color="blue"><b>=</b></font> [<font color="#808000"><i>H</i></font> | <font color="#808000"><i>T</i></font>].<br>
<font color="#808000"><i>H</i></font> <font color="blue"><b>=</b></font> <b>a</b>,<br>
<font color="#808000"><i>T</i></font> <font color="blue"><b>=</b></font> [<b>b</b>, <b>c</b>, <b>d</b>].<br>
<br>
?- <font color="#808000"><i>Head</i></font> <font color="blue"><b>=</b></font> голова, <font color="#808000"><i>Tail</i></font> <font color="blue"><b>=</b></font> [о, с, т, а, л, ь, н, о, е], <font color="#808000"><i>List</i></font> <font color="blue"><b>=</b></font> [<font color="#808000"><i>Head</i></font> | <font color="#808000"><i>Tail</i></font>].<br>
<font color="#808000"><i>Head</i></font> <font color="blue"><b>=</b></font> голова,<br>
<font color="#808000"><i>Tail</i></font> <font color="blue"><b>=</b></font> [о, с, т, а, л, ь, н, о, е],<br>
<font color="#808000"><i>List</i></font> <font color="blue"><b>=</b></font> [голова, о, с, т, а, л, ь, н, о|...].<br>
<br>
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> [<b>a</b> | [ <b>b</b> | [ <b>c</b> | [<b>d</b> | [] ] ] ] ]. <font color="#909090"><i>% напоминает <b>haskell</b>, не так ли? )<br></i></font>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> [<b>a</b>, <b>b</b>, <b>c</b>, <b>d</b>].<br>
<br>
?- [<font color="#808000"><i>A</i></font>,<font color="#808000"><i>B</i></font>,<font color="#808000"><i>C</i></font> | <font color="#808000"><i>Tail</i></font>] <font color="blue"><b>=</b></font> [1,2,3,4,5,6].<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 1,<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> 2,<br>
<font color="#808000"><i>C</i></font> <font color="blue"><b>=</b></font> 3,<br>
<font color="#808000"><i>Tail</i></font> <font color="blue"><b>=</b></font> [4, 5, 6].<br>
</font></code></blockquote>
В равнозначности синтаксисов можно убедиться запросом<br>
<br><blockquote><code><font size="2" face="Courier New">
?- [<font color="#808000"><i>H</i></font> | <font color="#808000"><i>T</i></font>] <font color="blue"><b>=</b></font> (.(<font color="#808000"><i>H</i></font>, <font color="#808000"><i>T</i></font>)).<br>
<font color="blue"><b><b>true</b></b></font>. <font color="#909090"><i>% т.е. справедливо при любых значениях неизвестных <font color="#808000"><i>H</i></font> и <font color="#808000"><i>T</i></font>.<br></i></font>
</font></code></blockquote>
Как видим, тут проявляется на первый взгляд не совсем привычное поведение знака "=", а именно то, что он работает "в обе стороны". И это очень важный момент. Дело в том, что в прологе знак "=" обозначает не обычное (императивное) равенство (присвоение), а <i>унификацию</i> (что в других языках называется сопоставление с образцом), а именно сопоставление левой и правой части и в случае удачного сопоставления конкретизация неизвестных значений.<br>
Фраза может выглядеть немного заумно, легче пояснить на примере.<br>
<br><blockquote><code><font size="2" face="Courier New">
?- aaa <font color="blue"><b>=</b></font> <b>bb</b>. <br>
<font color="blue"><b><b>false</b></b></font>. <font color="#909090"><i>% сопоставление неудачно (атомы не совпадают)<br></i></font>
<br>
?- aaa <font color="blue"><b>=</b></font> <b>aaa</b>.<br>
<font color="blue"><b><b>true</b></b></font>. <font color="#909090"><i>% удачно<br></i></font>
<br>
?- <b>aaa</b>(<b>bbb</b>) <font color="blue"><b>=</b></font> <b>aaa</b>(<b>bbb</b>).<br>
<font color="blue"><b><b>true</b></b></font>. <font color="#909090"><i>% удачно (функторы совпадают)<br></i></font>
<br>
?- <b>aaa</b>(<b>bbb</b>) <font color="blue"><b>=</b></font> <b>aaa</b>(<font color="#808000"><i>B</i></font>).<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> <b>bbb</b>. <font color="#909090"><i>% удачно + выполнена конкретизация<br></i></font>
<br>
?- <b>aaa</b>(<b>bbb</b>) <font color="blue"><b>=</b></font> <b>aaa</b>(<font color="#808000"><i>B</i></font>, <font color="#808000"><i>C</i></font>).<br>
<font color="blue"><b><b>false</b></b></font>. <font color="#909090"><i>% не удачно, арность функторов не совпадает, неизвестные <font color="#808000"><i>B</i></font> и С определены быть не могут<br></i></font>
<br>
?- <b>aaa</b>(<b>bbb</b>, <font color="#808000"><i>C</i></font>) <font color="blue"><b>=</b></font> <b>aaa</b>(<font color="#808000"><i>B</i></font>, <b>ccc</b>(1)).<br>
<font color="#808000"><i>C</i></font> <font color="blue"><b>=</b></font> <b>ccc</b>(1),<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> <b>bbb</b>.<br>
<font color="#909090"><i>% удачно + конкретизация<br></i></font>
<br>
?- [1,2] <font color="blue"><b>=</b></font> [1,2,3,4].<br>
<font color="blue"><b><b>false</b></b></font>. <font color="#909090"><i>% списки не совпадают<br></i></font>
<br>
?- [1,2 | <font color="#808000"><i>T</i></font>] <font color="blue"><b>=</b></font> [1,<font color="#808000"><i>B</i></font>,3,4].<br>
<font color="#808000"><i>T</i></font> <font color="blue"><b>=</b></font> [3, 4],<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> 2.<br>
<font color="#909090"><i>% удачно + конкретизация<br></i></font>
</font></code></blockquote>
Разобравшись немного с понятием унификации, становится понятно, почему<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2, <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 5.<br>
<font color="blue"><b><b>false</b></b></font>.<br></font></code></blockquote>
<br>
Выполнив первую унификацию, пролог система сопоставляет неизвестную A c числом 2. Таким образом вторая унификация будет ни что иное как 2 = 5, т.е. сопоставление чисел 2 и 5 которое конечно же окончится неудачей в виду того что числа не равны. Таким образом, в прологе переменные могут быть конкретизированы только один раз (по этому, например, попытки императивного программирования вида N = N + 1 в прологе не имеют смысла, подобное обычно делается через рекурсию).<br>
Чтобы точно уяснить смысл последнего запроса, нужно еще пояснить смысл функтора ",". Да, не удивляйтесь, "," это действительно функтор (а именно, инфиксный оператор с арностью 2). В этом можно убедиться, выполнив запросы<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <b>call</b>((,),<font color="#808000"><i>A</i></font><font color="blue"><b>=</b></font>2,<font color="#808000"><i>A</i></font><font color="blue"><b>=</b></font>5).<br>
<font color="blue"><b><b>false</b></b></font>.<br></font></code></blockquote>
<br>
а вот<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <b>call</b>((,),<font color="#808000"><i>A</i></font><font color="blue"><b>=</b></font>2,<font color="#808000"><i>A</i></font><font color="blue"><b>=</b></font><font color="#808000"><i>B</i></font>).<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2,<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> 2<br>
</font></code></blockquote>
что эквивалентно<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2, <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <font color="#808000"><i>B</i></font>.<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2,<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> 2.<br>
</font></code></blockquote>
здесь противоречий нет, и система просто конкретизирует значения неизвестных.<br>
<br>
&nbsp;&nbsp; &nbsp;Однако, мы отвлеклись. Оператор "," обозначает ни что иное, как логическое "И". Понятно что если мы говорим системе что некоторое число равно 2 <i>и</i> (при этом) оно же равно 5 то мы, очевидно, врем, о чем система нам и сообщает. Для логического "ИЛИ" предусмотрен оператор ";".<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2; <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 5.<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2 ;<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 5.<br>
</font></code></blockquote>
Собственно, ответ системы не представляет ничего удивительного. Она ответила ровно то, что мы ей сообщили, а именно, что неизвестное число это либо 2 либо 5.<br>
<br>
Впрочем если мы конкретизируем наш запрос (неизвестное число это либо 2 либо 5 и при этом оно четное), то и ответ системы обретет однозначность<br>
<br><blockquote><code><font size="2" face="Courier New">
?- (<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2; <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 5), <font color="#808000"><i>A</i></font> mod 2 <font color="blue"><b>=</b></font>:<font color="blue"><b>=</b></font> 0.<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2 ;<br>
<font color="blue"><b><b>false</b></b></font>.<br>
</font></code></blockquote>
Наблюдательные могут спросить, что же тогда есть false в конце - неужели унификация не удалась? Тут мы подошли ко второй особенности языка пролог, не свойственной больше почти никакому другому языку программирования (кроме Mercury =) ), а именно backtracking или если сказать по-русски - перебор с возвратом<span style="background-color: rgb(0, 255, 255);"></span>. Конкретно для последнего примера система рассуждает следующим образом - допустим A=2, проведем проверку на A mod 2 =:= 0 - это выполняется -&gt; сопоставление удачно - выполняется конкретизация (A=2), далее происходит откат (возврат) к первой части утверждения и проверяется гипотеза A = 5, она терпит крах и потому система показывает false.<br>
Забегая на перед, замечу, что можно отменить возврат (после первого удачного сопоставления) с помощью оператора отсечения "!"<br>
<br><blockquote><code><font size="2" face="Courier New">
?- (<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2; <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 5), <font color="#808000"><i>A</i></font> mod 2 <font color="blue"><b>=</b></font>:<font color="blue"><b>=</b></font> 0, <font color="blue"><b>!</b></font>.<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2.<br>
<font color="#909090"><i>% ответ системы однозначен<br></i></font>
</font></code></blockquote>
Попробуем выполнить арифметическое вычисление. <br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2 + 3 * 5.<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2+3*5.<br>
</font></code></blockquote>
тут нас ожидает конфуз. Оказывается, система воспринимает арифметические операции как обычную комбинацию функторов (впрочем наблюдательные могли заметить это выше). Действительно, запрос <br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> + <font color="#808000"><i>B</i></font> * <font color="#808000"><i>C</i></font> <font color="blue"><b>=</b></font> (+(<font color="#808000"><i>A</i></font>, *(<font color="#808000"><i>B</i></font>, <font color="#808000"><i>C</i></font>))).<br>
<font color="blue"><b><b>true</b></b></font>.<br>
</font></code></blockquote>
показывает что так и есть. Что же тогда делать? Однако, оказывается, есть специальный предикат is/2 (через "/" обычно обозначается арность предиката), который выполняет арифметическое действие.<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2 + 3 * 5, <font color="#808000"><i>B</i></font> <font color="blue"><b><b>is</b></b></font> <font color="#808000"><i>A</i></font>.<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> 2+3*5,<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> 17.<br>
</font></code></blockquote>
или просто<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <font color="#808000"><i>B</i></font> <font color="blue"><b><b>is</b></b></font> 2 + 3 * 5.<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> 17.<br>
</font></code></blockquote>
Пока что мы работали в интерактивном режиме, чтобы "пощупать" пролог на вкус. Обычно же, пролог-программы, как и программы на любом другом языке представляют собой файл с текстом программы. Обычной практикой является загрузка этого файла в интерактивную среду с помощью команды consult('file'). (или ее синтаксическим сахаром - [file].) и последующими запросами к программе, т.е. к фактам и предикатам в ней определенным.<br>
Пролог машина, используя описанные выше 2 основных механизма (унификация с конкретизацией + backtracking) вычисляет необходимый результат.<br>
<br>
Программа на прологе представляет собой обычно совокупность фактов и предикатов. Подробнее об этих понятиях. <br>
Факт есть некоторое отношение, а точнее сказать экземпляр такого отношения, например<br>
<br><blockquote><code><font size="2" face="Courier New">
<font color="#909090"><i>% собаки<br></i></font>
<b>dog</b>(<b>sharik</b>). <font color="#909090"><i>% дословно означает, что Шарик - собака<br></i></font>
<b>dog</b>(<b>tuzik</b>). <font color="#909090"><i>% --//--<br></i></font>
<br>
<font color="#909090"><i>% кошки<br></i></font>
<b>cat</b>(<b>pushok</b>).<br>
<b>cat</b>(<b>druzgok</b>).<br>
<br>
<font color="#909090"><i>% хомячки<br></i></font>
<b>hamster</b>(<b>pit</b>).<br>
<br>
<font color="#909090"><i>% мужчины<br></i></font>
<b>man</b>(<b>bill</b>).<br>
<b>man</b>(<b>george</b>).<br>
<b>man</b>(<b>barak</b>).<br>
<b>man</b>(<b>platon</b>).<br>
<b>man</b>(<b>sokrat</b>).<br>
<br>
<font color="#909090"><i>% женщины<br></i></font>
<b>woman</b>(<b>ann</b>).<br>
<b>woman</b>(<b>kate</b>).<br>
<b>woman</b>(<b>pam</b>).<br>
<br>
<font color="#909090"><i>% ныне покойные<br></i></font>
<b>dead</b>(<b>sharik</b>).<br>
<b>dead</b>(<b>platon</b>).<br>
<b>dead</b>(<b>sokrat</b>).<br>
<br>
<font color="#909090"><i>% возраст<br></i></font>
<b>age</b>(<b>sharik</b>, 18). <font color="#909090"><i>% возраст Шарика - 18 лет<br></i></font>
<b>age</b>(<b>tuzik</b>, 10). <font color="#909090"><i>% --//--<br></i></font>
<b>age</b>(<b>pushok</b>, 5).<br>
<b>age</b>(<b>druzhok</b>, 2).<br>
<b>age</b>(<b>bill</b>, 62).<br>
<b>age</b>(<b>george</b>, 62).<br>
<b>age</b>(<b>barak</b>, 47).<br>
<b>age</b>(<b>sokrat</b>, 70).<br>
<b>age</b>(<b>platon</b>, 80).<br>
<b>age</b>(<b>ann</b>, 20).<br>
<b>age</b>(<b>kate</b>, 25).<br>
<b>age</b>(<b>pam</b>, 30).<br>
</font></code></blockquote>
<span style="background-color: rgb(255, 153, 0);"></span><span style="background-color: rgb(255, 255, 255);">Предикаты же, это отношения, которые сопровождаются некоторыми дополнительными условиями (что-то вроде: "отношение справедливо, если выполнены след. условия ..."). Эти самые условия записываются через оператор ":-" . Напишем несколько предикатов для нашей базы фактов.</span><br style="background-color: rgb(255, 153, 0);"><br>
<blockquote><code><font size="2" face="Courier New"><font color="#909090"><i>% животные<br></i></font>
<b>animal</b>(<font color="#808000"><i>X</i></font>) :-<br>
&nbsp;&nbsp; &nbsp;<b>dog</b>(<font color="#808000"><i>X</i></font>); <font color="#909090"><i>% это либо собака<br></i></font>
&nbsp;&nbsp; &nbsp;<b>cat</b>(<font color="#808000"><i>X</i></font>); <font color="#909090"><i>% либо кошка<br></i></font>
&nbsp;&nbsp; &nbsp;<b>hamster</b>(<font color="#808000"><i>X</i></font>). <font color="#909090"><i>% либо хомячок<br></i></font>
<br>
<font color="#909090"><i>% Читается как: <font color="#808000"><i>X</i></font> - животное, если <font color="#808000"><i>X</i></font> - собака, либо Х - кошка, либо Х - хомяк.<br></i></font>
<br>
<font color="#909090"><i>% люди<br></i></font>
<b>human</b>(<font color="#808000"><i>X</i></font>) :-<br>
&nbsp;&nbsp; &nbsp;<b>man</b>(<font color="#808000"><i>X</i></font>); <font color="#909090"><i>% либо мужчина<br></i></font>
&nbsp;&nbsp; &nbsp;<b>woman</b>(<font color="#808000"><i>X</i></font>). <font color="#909090"><i>% либо женщина<br></i></font>
<br>
<font color="#909090"><i>% живые (или жившие) существа<br></i></font>
<b>living</b>(<font color="#808000"><i>X</i></font>) :-<br>
&nbsp;&nbsp; &nbsp;<b>animal</b>(<font color="#808000"><i>X</i></font>);<br>
&nbsp;&nbsp; &nbsp;<b>human</b>(<font color="#808000"><i>X</i></font>).<br>
<br>
<font color="#909090"><i>% живые (в данный момент) существа<br></i></font>
<b>alive</b>(<font color="#808000"><i>X</i></font>) :-<br>
&nbsp;&nbsp; &nbsp;<b>living</b>(<font color="#808000"><i>X</i></font>),<br>
&nbsp;&nbsp; &nbsp;<font color="blue"><b>\+</b></font> <b>dead</b>(<font color="#808000"><i>X</i></font>).<br>
<br>
<font color="#909090"><i>% старый<br></i></font>
<b>old</b>(<font color="#808000"><i>X</i></font>) :-<br>
&nbsp;&nbsp; &nbsp;(&nbsp;&nbsp; <b>animal</b>(<font color="#808000"><i>X</i></font>)<br>
&nbsp;&nbsp; &nbsp;-&gt;&nbsp; <b>age</b>(<font color="#808000"><i>X</i></font>, <font color="#808000"><i>Age</i></font>),<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <font color="#808000"><i>Age</i></font> &gt;<font color="blue"><b>=</b></font> 10 <font color="#909090"><i>% считаем, что животные старше 10 лет - старые<br></i></font>
&nbsp;&nbsp; &nbsp;;&nbsp;&nbsp; <b>human</b>(<font color="#808000"><i>X</i></font>),<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <b>age</b>(<font color="#808000"><i>X</i></font>, <font color="#808000"><i>Age</i></font>),<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <font color="#808000"><i>Age</i></font> &gt;<font color="blue"><b>=</b></font> 60 <font color="#909090"><i>% считаем, что люди старше 60 лет - старые<br></i></font>
&nbsp;&nbsp; &nbsp;), <br>
&nbsp;&nbsp; &nbsp;<font color="blue"><b>\+</b></font> <b>dead</b>(<font color="#808000"><i>X</i></font>). <font color="#909090"><i>% старые, но при этом - живые<br></i></font>
<br>
<font color="#909090"><i>% молодой - значит - живой и не старый<br></i></font>
<b>young</b>(<font color="#808000"><i>X</i></font>) :-<br>
&nbsp;&nbsp; &nbsp;<b>alive</b>(<font color="#808000"><i>X</i></font>),<br>
&nbsp;&nbsp; &nbsp;<font color="blue"><b>\+</b></font> <b>old</b>(<font color="#808000"><i>X</i></font>).<br>
</font></code></blockquote>
<br>
<span style="background-color: rgb(255, 153, 0);"></span><span style="background-color: rgb(255, 255, 255);">Полезно заметить, что факт - это фактически тоже разновидность предиката, более того вышеприведенные 3 факта woman(...) могут быть записаны одним предикатом<br>
<br>
<blockquote><code><font size="2" face="Courier New"><b>woman</b>(<font color="#808000"><i>X</i></font>) :- <font color="#808000"><i>X</i></font> <font color="blue"><b>=</b></font> ann; <font color="#808000"><i>X</i></font> <font color="blue"><b>=</b></font> kate; <font color="#808000"><i>X</i></font> <font color="blue"><b>=</b></font> <b>pam</b>.<br></font></code></blockquote>
<br>
или даже<br>
<br><blockquote><code><font size="2" face="Courier New">
<b>woman</b>(<font color="#808000"><i>X</i></font>) :- <font color="blue"><b><b>member</b></b></font>(<font color="#808000"><i>X</i></font>, [<b>ann</b>, <b>kate</b>, <b>pam</b>]).<br></font></code></blockquote>
</span><br style="background-color: rgb(255, 255, 255);"><span style="background-color: rgb(255, 255, 255);">но все же из соображений выразительности следует применять факты там где это логично.</span><br style="background-color: rgb(255, 153, 0);"><br style="background-color: rgb(255, 153, 0);"><span style="background-color: rgb(255, 255, 255);">Запросы к системе, ознакомленной с приведенной программой:<br>
<br>
<span style="background-color: rgb(255, 255, 0);"></span></span><blockquote><code><font size="2" face="Courier New">1 ?- <b>human</b>(<b>ann</b>).<br>
<font color="blue"><b><b>true</b></b></font>.<br>
<br>
?- <b>human</b>(<b>tuzik</b>).<br>
<font color="blue"><b><b>false</b></b></font>.<br>
<br>
?- <b>human</b>(<font color="#808000"><i>Who</i></font>).<br>
<font color="#808000"><i>Who</i></font> <font color="blue"><b>=</b></font> bill ;<br>
<font color="#808000"><i>Who</i></font> <font color="blue"><b>=</b></font> george ;<br>
<font color="#808000"><i>Who</i></font> <font color="blue"><b>=</b></font> barak ;<br>
<font color="#808000"><i>Who</i></font> <font color="blue"><b>=</b></font> platon ;<br>
<font color="#808000"><i>Who</i></font> <font color="blue"><b>=</b></font> sokrat ;<br>
<font color="#808000"><i>Who</i></font> <font color="blue"><b>=</b></font> ann ;<br>
<font color="#808000"><i>Who</i></font> <font color="blue"><b>=</b></font> kate ;<br>
<font color="#808000"><i>Who</i></font> <font color="blue"><b>=</b></font> <b>pam</b>.<br>
</font></code></blockquote>
Или так (получить сразу список):<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <b>bagof</b>(<font color="#808000"><i>H</i></font>, <b>human</b>(<font color="#808000"><i>H</i></font>), <font color="#808000"><i>Humans</i></font>).<br>
<font color="#808000"><i>Humans</i></font> <font color="blue"><b>=</b></font> [<b>bill</b>, <b>george</b>, <b>barak</b>, <b>platon</b>, <b>sokrat</b>, <b>ann</b>, <b>kate</b>, <b>pam</b>].<br>
<br>
?- <b>alive</b>(<b>sokrat</b>).<br>
<font color="blue"><b><b>false</b></b></font>.<br>
<br>
?- <b>alive</b>(<b>pit</b>).<br>
<font color="blue"><b><b>true</b></b></font>.<br>
<br>
<font color="#909090"><i>% перечислить молодых<br></i></font>
?- <b>young</b>(<font color="#808000"><i>Y</i></font>).<br>
<font color="#808000"><i>Y</i></font> <font color="blue"><b>=</b></font> pushok ;<br>
<font color="#808000"><i>Y</i></font> <font color="blue"><b>=</b></font> druzgok ;<br>
<font color="#808000"><i>Y</i></font> <font color="blue"><b>=</b></font> pit ;<br>
<font color="#808000"><i>Y</i></font> <font color="blue"><b>=</b></font> barak ;<br>
<font color="#808000"><i>Y</i></font> <font color="blue"><b>=</b></font> ann ;<br>
<font color="#808000"><i>Y</i></font> <font color="blue"><b>=</b></font> kate ;<br>
<font color="#808000"><i>Y</i></font> <font color="blue"><b>=</b></font> <b>pam</b>.<br>
<br>
<font color="#909090"><i>% перечислить молодых мужчин<br></i></font>
?- <b>young</b>(<font color="#808000"><i>H</i></font>), <b>man</b>(<font color="#808000"><i>H</i></font>).<br>
<font color="#808000"><i>H</i></font> <font color="blue"><b>=</b></font> barak ;<br>
<font color="blue"><b><b>false</b></b></font>.<br></font></code></blockquote>
<span style="background-color: rgb(255, 255, 255);"><br>
И даже<br>
<br><blockquote><code><font size="2" face="Courier New">
</span><font color="#909090"><i>% показать все пары живых существ, где одно старше другого в 2 раза<br></i></font>
?- <b>living</b>(<font color="#808000"><i>X</i></font>), <b>living</b>(<font color="#808000"><i>Y</i></font>), <b>age</b>(<font color="#808000"><i>X</i></font>, <font color="#808000"><i>AgeX</i></font>), <b>age</b>(<font color="#808000"><i>Y</i></font>, <font color="#808000"><i>AgeY</i></font>), <font color="#808000"><i>AgeX</i></font> <font color="blue"><b>=</b></font>:<font color="blue"><b>=</b></font> 2 * <font color="#808000"><i>AgeY</i></font>.<br>
<font color="#808000"><i>X</i></font> <font color="blue"><b>=</b></font> <b>tuzik</b>,<br>
<font color="#808000"><i>Y</i></font> <font color="blue"><b>=</b></font> <b>pushok</b>,<br>
<font color="#808000"><i>AgeX</i></font> <font color="blue"><b>=</b></font> 10,<br>
<font color="#808000"><i>AgeY</i></font> <font color="blue"><b>=</b></font> 5 ;<br>
<font color="#808000"><i>X</i></font> <font color="blue"><b>=</b></font> <b>ann</b>,<br>
<font color="#808000"><i>Y</i></font> <font color="blue"><b>=</b></font> <b>tuzik</b>,<br>
<font color="#808000"><i>AgeX</i></font> <font color="blue"><b>=</b></font> 20,<br>
<font color="#808000"><i>AgeY</i></font> <font color="blue"><b>=</b></font> 10 ;<br>
<font color="blue"><b><b>false</b></b></font>.<br></font></code></blockquote>
<span style="background-color: rgb(255, 153, 0);"></span><br>
Хотелось бы особо отметить чем предикаты пролога отличаются от функций (методов) императивного языка. <br>
Во-первых, они, в общем случае, могут быть "многовходовыми", что есть прямым следствием свойств рассмотренного понятия унификации, а во-вторых они могут "возвращать одновременно целый набор значений", что есть следствием бэктрекинга (правда, правильнее говорить, что предикат может оставлять несколько точек возврата).<br>
Действительно, рассмотрим тривиальный предикат<br>
<br><blockquote><code><font size="2" face="Courier New">
<b>same</b>(<font color="#808000"><i>A</i></font>, <font color="#808000"><i>B</i></font>) :-<br>
&nbsp;&nbsp;&nbsp; <font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <font color="#808000"><i>B</i></font>.<br>
</font></code></blockquote>
этот предикат допускает фактически 3 способа применения:<br>
<br><blockquote><code><font size="2" face="Courier New">
<font color="#909090"><i>% вперед<br></i></font>
?- <b>same</b>(<font color="#808000"><i>A</i></font>, <b>abc</b>).<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <b>abc</b>.<br>
<br>
<font color="#909090"><i>% назад<br></i></font>
?- <b>same</b>(<b>abc</b>, <font color="#808000"><i>A</i></font>).<br>
<font color="#808000"><i>A</i></font> <font color="blue"><b>=</b></font> <b>abc</b>.<br>
<br>
<font color="#909090"><i>% проверка на равенство<br></i></font>
?- <b>same</b>(<b>abc</b>, <b>abc</b>).<br>
<font color="blue"><b><b>true</b></b></font>.<br>
<br>
?- <b>same</b>(<b>abc</b>, <b>aaa</b>).<br>
<font color="blue"><b><b>false</b></b></font>.<br></font></code></blockquote>
<br>
заметим еще, что этот предикат может быть записан в виде факта:<br>
<br><blockquote><code><font size="2" face="Courier New">
<b>same</b>(<font color="#808000"><i>A</i></font>, <font color="#808000"><i>A</i></font>).<br></font></code></blockquote>
<br>
<span style="background-color: rgb(255, 255, 255);">Более показательный в этом плане пример с предикатом append (сложение списков).</span><span style="background-color: rgb(159, 197, 232);"><blockquote><code><font size="2" face="Courier New"><font color="#909090"><i>% сложение списков<br></i></font>
</span>8 ?- <font color="blue"><b><b>append</b></b></font>([<b>a</b>, <b>b</b>], [<b>c</b>, <b>d</b>, <b>e</b>], <font color="#808000"><i>L</i></font>).<br>
<font color="#808000"><i>L</i></font> <font color="blue"><b>=</b></font> [<b>a</b>, <b>b</b>, <b>c</b>, <b>d</b>, <b>e</b>].<br>
<br>
<font color="#909090"><i>% вычитание списков<br></i></font>
?- <font color="blue"><b><b>append</b></b></font>(<font color="#808000"><i>L1</i></font>, [<b>c</b>, <b>d</b>, <b>e</b>], [<b>a</b>, <b>b</b>, <b>c</b>, <b>d</b>, <b>e</b>]).<br>
<font color="#808000"><i>L1</i></font> <font color="blue"><b>=</b></font> [<b>a</b>, <b>b</b>] ;<br>
<font color="blue"><b><b>false</b></b></font>.<br>
<br>
?- <font color="blue"><b><b>append</b></b></font>([<b>a</b>, <b>b</b>], <font color="#808000"><i>L2</i></font>, [<b>a</b>, <b>b</b>, <b>c</b>, <b>d</b>, <b>e</b>]).<br>
<font color="#808000"><i>L2</i></font> <font color="blue"><b>=</b></font> [<b>c</b>, <b>d</b>, <b>e</b>].<br>
<br>
<font color="#909090"><i>% не возможно, поскольку массив [<b>a</b>, <b>b</b>, <b>c</b>, <b>d</b>, <b>e</b>] не начинается с [<b>a</b>, <b>c</b>]<br></i></font>
?- <font color="blue"><b><b>append</b></b></font>([<b>a</b>, <b>c</b>], <font color="#808000"><i>L2</i></font>, [<b>a</b>, <b>b</b>, <b>c</b>, <b>d</b>, <b>e</b>]).<br>
<font color="blue"><b><b>false</b></b></font>.<br>
<br>
<font color="#909090"><i>% проверка на правильность сложения<br></i></font>
?- <font color="blue"><b><b>append</b></b></font>(<font color="#008000"><b>"Привет "</b></font>, <font color="#008000"><b>"Мир"</b></font>, <font color="#008000"><b>"Привет Мир"</b></font>).<br>
<font color="blue"><b><b>true</b></b></font>.<br>
<br>
?- <font color="blue"><b><b>append</b></b></font>(<font color="#008000"><b>"Привет "</b></font>, <font color="#008000"><b>"Мир"</b></font>, <font color="#008000"><b>"Привет Habrahabr"</b></font>).<br>
<font color="blue"><b><b>false</b></b></font>.<br>
<br>
<font color="#909090"><i>% даже перебор всех возможных вариантов сложения, дающих данный список<br></i></font>
?- <font color="blue"><b><b>append</b></b></font>(<font color="#808000"><i>L1</i></font>, <font color="#808000"><i>L2</i></font>, [<b>a</b>,<b>b</b>,<b>c</b>]).<br>
<font color="#808000"><i>L1</i></font> <font color="blue"><b>=</b></font> [],<br>
<font color="#808000"><i>L2</i></font> <font color="blue"><b>=</b></font> [<b>a</b>, <b>b</b>, <b>c</b>] ;<br>
<font color="#808000"><i>L1</i></font> <font color="blue"><b>=</b></font> [<b>a</b>],<br>
<font color="#808000"><i>L2</i></font> <font color="blue"><b>=</b></font> [<b>b</b>, <b>c</b>] ;<br>
<font color="#808000"><i>L1</i></font> <font color="blue"><b>=</b></font> [<b>a</b>, <b>b</b>],<br>
<font color="#808000"><i>L2</i></font> <font color="blue"><b>=</b></font> [<b>c</b>] ;<br>
<font color="#808000"><i>L1</i></font> <font color="blue"><b>=</b></font> [<b>a</b>, <b>b</b>, <b>c</b>],<br>
<font color="#808000"><i>L2</i></font> <font color="blue"><b>=</b></font> [] ;<br>
<font color="blue"><b><b>false</b></b></font>.<br>
<br>
<font color="#909090"><i>% и даже все возможные разбиения списка по некоторому элементу<br></i></font>
?- <font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> [<b>c</b>,<b>c</b>,<b>c</b>,<b>separator</b>,<b>d</b>,<b>d</b>,<b>separator</b>,<b>e</b>,<b>e</b>,<b>e</b>,<b>e</b>], <font color="blue"><b><b>append</b></b></font>(<font color="#808000"><i>L1</i></font>, [<b>separator</b> | <font color="#808000"><i>L2</i></font>], <font color="#808000"><i>B</i></font>).<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> [<b>c</b>, <b>c</b>, <b>c</b>, <b>separator</b>, <b>d</b>, <b>d</b>, <b>separator</b>, <b>e</b>, <b>e</b>|...],<br>
<font color="#808000"><i>L1</i></font> <font color="blue"><b>=</b></font> [<b>c</b>, <b>c</b>, <b>c</b>],<br>
<font color="#808000"><i>L2</i></font> <font color="blue"><b>=</b></font> [<b>d</b>, <b>d</b>, <b>separator</b>, <b>e</b>, <b>e</b>, <b>e</b>, <b>e</b>] ;<br>
<font color="#808000"><i>B</i></font> <font color="blue"><b>=</b></font> [<b>c</b>, <b>c</b>, <b>c</b>, <b>separator</b>, <b>d</b>, <b>d</b>, <b>separator</b>, <b>e</b>, <b>e</b>|...],<br>
<font color="#808000"><i>L1</i></font> <font color="blue"><b>=</b></font> [<b>c</b>, <b>c</b>, <b>c</b>, <b>separator</b>, <b>d</b>, <b>d</b>],<br>
<font color="#808000"><i>L2</i></font> <font color="blue"><b>=</b></font> [<b>e</b>, <b>e</b>, <b>e</b>, <b>e</b>] ;<br>
<font color="blue"><b><b>false</b></b></font>.<br></font></code></blockquote>
<br>
И все это используя только один предикат!<br>
<br>
Чтобы подытожить, можно отметить что программа на прологе представляет собой одновременно базу данных (не реляционную, конечно, но допускающую практически любую функциональную зависимость) (факты) и инфраструктуру запросов к этой базе данных (предикаты), позволяющую построить по данным из базы данных новые отношения, зависимости, или получить некий результат, связанный с данными. (Впрочем, факты могут и отсутствовать)<br>
При этом сами запросы (предикаты) способны иметь довольно замысловатую логику или даже выполнять вычислительные задачи. Чтобы окончательно повергнуть читателя, добавим, что предикаты способны динамически порождать факты и даже другие предикаты. Отличие от, вероятно, знакомой читателю императивной парадигмы программирования - в декларативной сущности получаемых программ.<br>
Обратная сторона подобной гибкости концепции, разумеется, скорость (о чем справедливо указывали коментаторы предыдущего поста по прологу, впрочем коммерческие реализации пролога обладают довольно недурной производительностью). <br>
Однако соблазнительная сторона такого подхода - возможность чрезвычайно выразительного (пусть, возможно, и не быстрого) решения на прологе задач символьных вычислений, парсинга текста и сложных структур данных (в т.ч. по грамматикам), задачах поиска, экспертных системах, задачах искуственного интеллекта. <br>
<br>
Как-то гуляя по просторам сайта рефал-сообщества (еще один интересный язык программирования, местами идейно перекликающийся с прологом), наткнулся на сравнение Refal'а с Java'ой на примере решения конкретной задачи <a title="http://wiki.botik.ru/Refaldevel/ForJavaProgrammer" href="http://wiki.botik.ru/Refaldevel/ForJavaProgrammer" id="kiny">http://wiki.botik.ru/Refaldevel/ForJavaProgrammer</a> (собственно первоисточник - тут <a title="http://nuclight.livejournal.com/111696.html" href="http://nuclight.livejournal.com/111696.html" id="l7cz">http://nuclight.livejournal.com/111696.html</a> ). Для интереса написал решение на прологе (написание заняло ~10 мин).<br>
<br>
<span style="background-color: rgb(255, 153, 0);"></span><br><blockquote><code><font size="2" face="Courier New">
<b>ischar</b>(<font color="#808000"><i>H</i></font>, [<font color="#808000"><i>H</i></font>]).<br>
<br>
<font color="#909090"><i>% пустые строка соответстует пустому паттерну.<br></i></font>
<b>matches</b>([], []) :-<font color="blue"><b>!</b></font>.<br>
<br>
<font color="#909090"><i>% если равны первый знак патерна и строки, или первый знак паттерна <font color="#008000"><b>"?"</b></font><br></i></font>
<font color="#909090"><i>% то для соответствия должны соответствовать <font color="#008000"><b>"хвосты"</b></font> строки и паттерна<br></i></font>
<b>matches</b>([<font color="#808000"><i>H</i></font> | <font color="#808000"><i>T</i></font>], [<font color="#808000"><i>H1</i></font> | <font color="#808000"><i>T1</i></font>]) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#808000"><i>H</i></font> <font color="blue"><b>=</b></font> <font color="#808000"><i>H1</i></font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>ischar</b>(<font color="#808000"><i>H</i></font>, <font color="#008000"><b>"?"</b></font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>matches</b>(<font color="#808000"><i>T</i></font>, <font color="#808000"><i>T1</i></font>), <font color="blue"><b>!</b></font>.<br>
<br>
<b>matches</b>([<font color="#808000"><i>H</i></font> | <font color="#808000"><i>T</i></font>], <font color="#808000"><i>T1</i></font>) :-<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>ischar</b>(<font color="#808000"><i>H</i></font>, <font color="#008000"><b>"*"</b></font>), <font color="#909090"><i>% иначе, если первая буква паттерна * то<br></i></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue"><b><b>append</b></b></font>(<b>_</b>, <font color="#808000"><i>T2</i></font>, <font color="#808000"><i>T1</i></font>), <font color="#909090"><i>% некая подстрока <font color="#808000"><i>T2</i></font> хвоста строки <font color="#808000"><i>T1</i></font> <br></i></font>
&nbsp;&nbsp;&nbsp;&nbsp;<b>matches</b>(<font color="#808000"><i>T</i></font>, <font color="#808000"><i>T2</i></font>), <font color="blue"><b>!</b></font>. <font color="#909090"><i>% должна соответствовать хвосту паттерна<br></i></font></font></code></blockquote>
<br>
<br>
и проверка (остальные тест-кейсы опустил из-за того, что очень длинные строки распирают страницу сайта)<br>
<br><blockquote><code><font size="2" face="Courier New">
<b>check</b>:-<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>matches</b>(<font color="#008000"><b>"ASDFAASDASDAAASDASDASD"</b></font>, <font color="#008000"><b>"ASDFAASDASDAAASDASDASD"</b></font>),<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>matches</b>(<font color="#008000"><b>"*"</b></font>, <font color="#008000"><b>"ASDFAASDASDAAASDASDASD"</b></font>),<br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>matches</b>(<font color="#008000"><b>"A?DF?A*ASD*ASDA?DASD"</b></font>, <font color="#008000"><b>"ASDFAASDASDAAASDASDASD"</b></font>),<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue"><b>\+</b></font> <b>matches</b>(<font color="#008000"><b>"ASDFAASDADAAASDASDASD"</b></font>, <font color="#008000"><b>"ASDFAASASDAAASDASDASD"</b></font>).<br></font></code></blockquote>
<br>
Запускаем проверку:<br>
<br><blockquote><code><font size="2" face="Courier New">
?- <b>check</b>.<br>
<font color="blue"><b><b>true</b></b></font>. <font color="#909090"><i>% алгоритм работает верно на тестовых данных<br></i></font>
</font></code></blockquote>
Полный текст программ доступен <a href="http://narod.ru/disk/5040252000/pl_article1_code.zip.html">здесь</a>.<br>
<br>
И последнее, рекомендации и подсказки.<br>
<br>
1) Все примеры приведены для диалеката SWI-Prolog (по моему скромному мнению - самый вменяемый и близкий к классическому прологу). Правда, рекомендую использовать версию 5.7.3 (бета) доступную здесь <a href="http://prolog.cs.vu.nl/download/devel/bin/">http://prolog.cs.vu.nl/download/devel/bin/</a> (файл w32pl573.exe для win) или 5.6.X. В версии 5.7.4 присутствует небольшая ошибка при работе в пролог-консоли (<a href="https://mailbox.iai.uni-bonn.de/mailman/public/swi-prolog/2009/000904.html">https://mailbox.iai.uni-bonn.de/mailman/public/swi-prolog/2009/000904.html</a>).<br>
2) Загрузка файла:<br>
<blockquote><code><font size="2" face="Courier New">?- [<b>file</b>].<br></font></code></blockquote>
нескольких файлов:<br>
<blockquote><code><font size="2" face="Courier New">?- [<b>file1</b>, <b>file2</b>, <b>file3</b>].<br></font></code></blockquote>
3) Хелп по предикату:<br>
<blockquote><code><font size="2" face="Courier New">?- <b>help</b>(<font color="blue"><b><b>is</b></b></font>).<br></font></code></blockquote>
или<br>
<blockquote><code><font size="2" face="Courier New">?- <b>apropos</b>(<b>test</b>).<br></font></code></blockquote>
4) редактирование текущего загруженного файла (удобный редактор с подсветкой, к слову, написанный на прологе).<br>
<blockquote><code><font size="2" face="Courier New">?- <b>edit</b>.<br></font></code></blockquote>
редактировать другой файл<br>
<blockquote><code><font size="2" face="Courier New">?- <b>edit</b>(<b>file</b>).<br></font></code></blockquote>
5) Пошаговая отладка (консольная):<br>
<blockquote><code><font size="2" face="Courier New">?- <b>trace</b>, <b>do_smth_with</b>(<b>arg</b>).<br></font></code></blockquote>
графическая:<br>
<blockquote><code><font size="2" face="Courier New">?- <b>gtrace</b>, <b>do_smth_with</b>(<b>arg</b>).<br></font></code></blockquote>
<br>
На сегодня, все. Спасибо, что дочитали =).