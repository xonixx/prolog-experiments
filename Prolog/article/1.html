Довольно оживленное обсуждение предыдущей стати (<a title="http://habrahabr.ru/blogs/programming/47416/" href="http://habrahabr.ru/blogs/programming/47416/" id="l1l-">http://habrahabr.ru/blogs/programming/47416/</a>) показало, что тема пролога оказалась интересна сообществу.<br>Чтобы заинтересовать еще более читателя и вместе с тем облегчить ему начало работы с этим языком, я решил написать немного начальных данных о прологе.<br><br>Кратко основные особенности.<br><br>Типы данных<br><br><i>Числа</i><br><br>?- A = 12, B = -0.5e4.<br>A = 12,<br>B = -5000.0.<br><br>?- number($A), number($B).<br>true. % показываем, что тип переменных - числа<br><br>Сразу нужно сделать важную оговорку. Все переменные (неизвестные) обозначаются <i>с большой буквы</i>.<br><br><i>Атомы</i><br><br> ?- A = abc, B = 'Hello World'.<br>A = abc,<br>B = 'Hello World'.<br><br>?- atom($A), atom($B).<br>true. % показываем, что тип переменных - атомы<br><br><i>Строки</i><br><br>?- S = "Привет мир".<br>S = [1055, 1088, 1080, 1074, 1077, 1090, 32, 1084, 1080|...].<br><br>Видно, что строки являются списками кодов символов, т.е. к ним применимы все те же операции что и к спискам, но об этом позже.<br><br><i>Списки</i><br><br>?- A=[], B=[a, foo, 123, [[[[[1,2,42]],bar]]], "Привет", A], C=[A,B].<br>A = [], % пустой список<br>B = [a, foo, 123, [[[[[1|...]], bar]]], [1055, 1088, 1080, 1074|...], []],<br>C = [[], [a, foo, 123, [[[[...]|...]]], [1055, 1088|...], []]]<br><br>Видим, что списки<br>1) могут быть разнородными (содержать любые комбинации выше- (и ниже-) перечисленных типов)<br>2) могут быть вложенными<br><br><i>Структуры</i><br><br>?- A = aaa(bb), B = aaa(bbbbbb, 123, [456, c]), C = ccc(ddd(eee), fff, g(h(i(j(kkkkk))))).<br>A = aaa(bb),<br>B = aaa(bbbbbb, 123, [456, c]),<br>C = ccc(ddd(eee), fff, g(h(i(j(kkkkk)))))<br><br>Пример осмысленнее:<br><br>?- Family = family(father(bill, age(37)), mother(ann, age(34)), children([son(john, age(10)), daughter(jill, age(8))])).<br>Family = family(father(bill, age(37)), mother(ann, age(34)), children([son(john, age(10)), daughter(jill, age(8))]))<br><br>Примеры посложнее:<br><br>?- A = aaa(foo, bar, "абв", [12, 13], 123.4e34), B = bbb(cc, A, [A, fff(A)]), C=foo(foo(foo(foo(bar)))), D=(+(2, *(3, -(7, 2)))).<br>A = aaa(foo, bar, [1072, 1073, 1074], [12, 13], 1.234e+036),<br>B = bbb(cc, aaa(foo, bar, [1072, 1073, 1074], [12, 13], 1.234e+036), [aaa(foo, bar, [1072, 1073, 1074], [12, 13], 1.234e+036), fff(aaa(foo, bar, [1072, 1073, 1074], [12, 13], 1.234e+036))]),<br>C = foo(foo(foo(foo(bar)))),<br>D = 2+3* (7-2)<br><br>?- C=cc(1, C), cc(1, cc(1, B))=C, C=B. % B и С совпадают<br>C = cc(1, **), % рекурсивная структура, с бесконечной вложенностью<br>B = cc(1, **).<br><br>Структура в прологе представляется функтором (имя структуры, то что до скобок) и параметрами (то что в скобках). Число параметров называется <i>арностью</i> функтора.&nbsp; <br>Как видим, структуры тоже могут быть вложенными.<br>Последний запрос может быть не совсем понятен, но должен стать понятен в процессе прочтения статьи.<br><br>Заметим, что между этими типами существует глубокая связь, например, списки есть ни что иное, как более красивое (синтаксический сахар) применение функтора "."<br><br>?- A = (.(1,.(2, .(aa, .(bbb, []))))).<br>A = [1, 2, aa, bbb].<br><br>Забегая на перед скажем, что так можно разбивать список на голову и хвост<br><br> ?- [a,b,c,d] = (.(H, T)).<br>H = a,<br>T = [b, c, d].<br><br>Хотя так никто не делает, в виду того, что для конструирования списков из головы и хвоста (а также обратное преобразование, т.е. разделение списка на голову и хвост) есть более удобный синтаксис вида [H | T].<br><br>22 ?- [a,b,c,d] = [H | T].<br>H = a,<br>T = [b, c, d].<br><br>25 ?- Head = голова, Tail = [о, с, т, а, л, ь, н, о, е], List = [Head | Tail].<br>Head = голова,<br>Tail = [о, с, т, а, л, ь, н, о, е],<br>List = [голова, о, с, т, а, л, ь, н, о|...].<br><br>26 ?- A = [a | [ b | [ c | [d | [] ] ] ] ]. % напоминает haskell, не так ли? )<br>A = [a, b, c, d].<br><br>27 ?- [A,B,C | Tail] = [1,2,3,4,5,6].<br>A = 1,<br>B = 2,<br>C = 3,<br>Tail = [4, 5, 6].<br><br>В равнозначности синтаксисов можно убедиться запросом<br><br>?- [H | T] = (.(H, T)).<br>true.<br>% т.е. справедливо при любых значениях неизвестных H и T.<br><br>Как видим, тут проявляется на первый взгляд не совсем привычное поведение знака "=", а именно то, что он работает "в обе стороны". И это очень важный момент. Дело в том, что в прологе знак "=" обозначает не обычное (императивное) равенство (присвоение), а <i>унификацию</i> (что в других языках называется сопоставление с образцом), а именно сопоставление левой и правой части и в случае удачного сопоставления конкретизация неизвестных значений.<br>Фраза может выглядеть немного заумно, легче пояснить на примере.<br><br>28 ?- aaa = bb. <br>false. % сопоставление неудачно (атомы не совпадают)<br><br>29 ?- aaa = aaa.<br>true. % удачно<br><br>30 ?- aaa(bbb) = aaa(bbb).<br>true. % удачно (функторы совпадают)<br><br>31 ?- aaa(bbb) = aaa(B).<br>B = bbb. % удачно + выполнена конкретизация<br><br>32 ?- aaa(bbb) = aaa(B, C).<br>false. % не удачно, арность функторов не совпадает, неизвестные B и С определены быть не могут<br><br>33 ?- aaa(bbb, C) = aaa(B, ccc(1)).<br>C = ccc(1),<br>B = bbb.<br>% удачно + конкретизация<br><br>34 ?- [1,2] = [1,2,3,4].<br>false. % списки не совпадают<br><br>35 ?- [1,2 | T] = [1,B,3,4].<br>T = [3, 4],<br>B = 2.<br>% удачно + конкретизация<br><br>Разобравшись немного с понятием унификации, становится понятно, почему<br><br>?- A = 2, A = 5.<br>false.<br><br>Выполнив первую унификацию, пролог система сопоставляет неизвестную A c числом 2. Таким образом вторая унификация будет ни что иное как 2 = 5, т.е. сопоставление чисел 2 и 5 которое конечно же окончится неудачей в виду того что числа не равны. Таким образом, в прологе переменные могут быть конкретизированы только один раз (по этому, например, попытки императивного программирования вида N = N + 1 в прологе не имеют смысла, подобное обычно делается через рекурсию).<br>Чтобы точно уяснить смысл последнего запроса, нужно еще пояснить смысл функтора ",". Да, не удивляйтесь, "," это действительно функтор (а именно, инфиксный оператор с арностью 2). В этом можно убедиться, выполнив запросы<br><br>19 ?- call((,),A=2,A=5).<br>false.<br><br>а вот<br><br>20 ?- call((,),A=2,A=B).<br>A = 2,<br>B = 2<br><br>что эквивалентно<br><br> ?- A = 2, A = B.<br>A = 2,<br>B = 2.<br><br>здесь противоречий нет, и система просто конкретизирует значения неизвестных.<br><br>&nbsp;&nbsp; &nbsp;Однако, мы отвлеклись. Оператор "," обозначает ни что иное, как логическое "И". Понятно что если мы говорим системе что некоторое число равно 2 <i>и</i> (при этом) оно же равно 5 то мы, очевидно, врем, о чем система нам и сообщает. Для логического "ИЛИ" предусмотрен оператор ";".<br><br> ?- A = 2; A = 5.<br>A = 2 ;<br>A = 5.<br><br>Собственно, ответ системы не представляет ничего удивительного. Она ответила ровно то, что мы ей сообщили, а именно, что неизвестное число это либо 2 либо 5.<br><br>Впрочем если мы конкретизируем наш запрос (неизвестное число это либо 2 либо 5 и при этом оно четное), то и ответ системы обретет однозначность<br><br>?- (A = 2; A = 5), A mod 2 =:= 0.<br>A = 2 ;<br>false.<br><br>Наблюдательные могут спросить, что же тогда есть false в конце - неужели унификация не удалась? Тут мы подошли ко второй особенности языка пролог, не свойственной больше почти никакому другому языку программирования (кроме Mercury =) ), а именно backtracking или если сказать по-русски - перебор с возвратом<span style="background-color: rgb(0, 255, 255);"></span>. Конкретно для последнего примера система рассуждает следующим образом - допустим A=2, проведем проверку на A mod 2 =:= 0 - это выполняется -&gt; сопоставление удачно - выполняется конкретизация (A=2), далее происходит откат (возврат) к первой части утверждения и проверяется гипотеза A = 5, она терпит крах и потому система показывает false.<br>Забегая на перед, замечу, что можно отменить возврат (после первого удачного сопоставления) с помощью оператора отсечения "!"<br><br> ?- (A = 2; A = 5), A mod 2 =:= 0, !.<br>A = 2.<br>% ответ системы однозначен<br><br>Попробуем выполнить арифметическое вычисление. <br> ?- A = 2 + 3 * 5.<br>A = 2+3*5.<br><br>тут нас ожидает конфуз. Оказывается, система воспринимает арифметические операции как обычную комбинацию функторов (впрочем наблюдательные могли заметить это выше). Действительно, запрос <br><br> ?- A + B * C = (+(A, *(B, C))).<br>true.<br><br>показывает что так и есть. Что же тогда делать? Однако, оказывается, есть специальный предикат is/2 (через "/" обычно обозначается арность предиката), который выполняет арифметическое действие.<br><br> ?- A = 2 + 3 * 5, B is A.<br>A = 2+3*5,<br>B = 17.<br><br>или просто<br><br>?- B is 2 + 3 * 5.<br>B = 17.<br><br>Пока что мы работали в интерактивном режиме, чтобы "пощупать" пролог на вкус. Обычно же, пролог-программы, как и программы на любом другом языке представляют собой файл с текстом программы. Обычной практикой является загрузка этого файла в интерактивную среду с помощью команды consult('file'). (или ее синтаксическим сахаром - [file].) и последующими запросами к программе, т.е. к фактам и предикатам в ней определенным.<br>Пролог машина, используя описанные выше 2 основных механизма (унификация с конкретизацией + backtracking) вычисляет необходимый результат.<br><br>Программа на прологе представляет собой обычно совокупность фактов и предикатов. Подробнее об этих понятиях. <br>Факт есть некоторое отношение, а точнее сказать экземпляр такого отношения, например<br><br>% собаки<br>dog(sharik). % дословно означает, что Шарик - собака<br>dog(tuzik). % --//--<br><br>% кошки<br>cat(pushok).<br>cat(druzgok).<br><br>% хомячки<br>hamster(pit).<br><br>% мужчины<br>man(bill).<br>man(george).<br>man(barak).<br>man(platon).<br>man(sokrat).<br><br>% женщины<br>woman(ann).<br>woman(kate).<br>woman(pam).<br><br>% ныне покойные<br>dead(sharik).<br>dead(platon).<br>dead(sokrat).<br><br>% возраст<br>age(sharik, 18). % возраст Шарика - 18 лет<br>age(tuzik, 10). % --//--<br>age(pushok, 5).<br>age(druzhok, 2).<br>age(bill, 62).<br>age(george, 62).<br>age(barak, 47).<br>age(sokrat, 70).<br>age(platon, 80).<br>age(ann, 20).<br>age(kate, 25).<br>age(pam, 30).<br><br><span style="background-color: rgb(255, 153, 0);"></span><span style="background-color: rgb(255, 255, 255);">Предикаты же, это отношения, которые сопровождаются некоторыми дополнительными условиями (что-то вроде: "отношение справедливо, если выполнены след. условия ..."). Эти самые условия записываются через оператор ":-" . Напишем несколько предикатов для нашей базы фактов.</span><br style="background-color: rgb(255, 153, 0);"><br>% животные<br>animal(X) :-<br>&nbsp;&nbsp; &nbsp;dog(X); % это либо собака<br>&nbsp;&nbsp; &nbsp;cat(X); % либо кошка<br>&nbsp;&nbsp; &nbsp;hamster(X). % либо хомячок<br><br>Читается как: X - животное, если X - собака, либо Х - кошка, либо Х - хомяк.<br><br>% люди<br>human(X) :-<br>&nbsp;&nbsp; &nbsp;man(X); % либо мужчина<br>&nbsp;&nbsp; &nbsp;woman(X). % либо женщина<br><br>% живые (или жившие) существа<br>living(X) :-<br>&nbsp;&nbsp; &nbsp;animal(X);<br>&nbsp;&nbsp; &nbsp;human(X).<br><br>% живые (в данный момент) существа<br>alive(X) :-<br>&nbsp;&nbsp; &nbsp;living(X),<br>&nbsp;&nbsp; &nbsp;\+ dead(X).<br><br>% старый<br>old(X) :-<br>&nbsp;&nbsp; &nbsp;(&nbsp;&nbsp; animal(X)<br>&nbsp;&nbsp; &nbsp;-&gt;&nbsp; age(X, Age),<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Age &gt;= 10 % считаем, что животные старше 10 лет - старые<br>&nbsp;&nbsp; &nbsp;;&nbsp;&nbsp; human(X),<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; age(X, Age),<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Age &gt;= 60 % считаем, что люди старше 60 лет - старые<br>&nbsp;&nbsp; &nbsp;), <br>&nbsp;&nbsp; &nbsp;\+ dead(X). % старые, но при этом - живые<br><br>% молодой - значит - живой и не старый<br>young(X) :-<br>&nbsp;&nbsp; &nbsp;alive(X),<br>&nbsp;&nbsp; &nbsp;\+ old(X).<br><br><br><span style="background-color: rgb(255, 153, 0);"></span><span style="background-color: rgb(255, 255, 255);">Полезно заметить, что факт - это фактически тоже разновидность предиката, более того вышеприведенные 3 факта woman(...) могут быть записаны одним предикатом<br><br>woman(X) :- X = ann; X = kate; X = pam.<br><br>или даже<br><br>woman(X) :- member(X, [ann, kate, pam]).<br></span><br style="background-color: rgb(255, 255, 255);"><span style="background-color: rgb(255, 255, 255);">но все же из соображений выразительности следует применять факты там где это логично.</span><br style="background-color: rgb(255, 153, 0);"><br style="background-color: rgb(255, 153, 0);"><span style="background-color: rgb(255, 255, 255);">Запросы к системе, ознакомленной с приведенной программой:<br><br><span style="background-color: rgb(255, 255, 0);"></span></span>1 ?- human(ann).<br>true.<br><br>2 ?- human(tuzik).<br>false.<br><br>3 ?- human(Who).<br>Who = bill ;<br>Who = george ;<br>Who = barak ;<br>Who = platon ;<br>Who = sokrat ;<br>Who = ann ;<br>Who = kate ;<br>Who = pam.<br><br>Или так (получить сразу список):<br><br>3 ?- bagof(H, human(H), Humans).<br>Humans = [bill, george, barak, platon, sokrat, ann, kate, pam].<br><br>10 ?- alive(sokrat).<br>false.<br><br>11 ?- alive(pit).<br>true.<br><br>% перечислить молодых<br>?- young(Y).<br>Y = pushok ;<br>Y = druzgok ;<br>Y = pit ;<br>Y = barak ;<br>Y = ann ;<br>Y = kate ;<br>Y = pam.<br><br>% перечислить молодых мужчин<br><br>?- young(H), man(H).<br>H = barak ;<br>false.<br><span style="background-color: rgb(255, 255, 255);"><br>И даже<br><br></span>% показать все пары живых существ, где одно старше другого в 2 раза<br>?- living(X), living(Y), age(X, AgeX), age(Y, AgeY), AgeX =:= 2 * AgeY.<br>X = tuzik,<br>Y = pushok,<br>AgeX = 10,<br>AgeY = 5 ;<br>X = ann,<br>Y = tuzik,<br>AgeX = 20,<br>AgeY = 10 ;<br>false.<br><span style="background-color: rgb(255, 153, 0);"></span><br>Хотелось бы особо отметить чем предикаты пролога отличаются от функций (методов) императивного языка. <br>Во-первых, они, в общем случае, могут быть "многовходовыми", что есть прямым следствием свойств рассмотренного понятия унификации, а во-вторых они могут "возвращать одновременно целый набор значений", что есть следствием бэктрекинга (правда, правильнее говорить, что предикат может оставлять несколько точек возврата).<br>Действительно, рассмотрим тривиальный предикат<br><br>same(A, B) :-<br>&nbsp;&nbsp;&nbsp; A = B.<br><br>этот предикат допускает фактически 3 способа применения:<br><br>% вперед<br>2 ?- same(A, abc).<br>A = abc.<br><br>% назад<br>3 ?- same(abc, A).<br>A = abc.<br><br>% проверка на равенство<br>4 ?- same(abc, abc).<br>true.<br><br>5 ?- same(abc, aaa).<br>false.<br><br>заметим еще, что этот предикат может быть записан в виде факта:<br><br>same(A, A).<br><br><span style="background-color: rgb(255, 255, 255);">Более показательный в этом плане пример с предикатом append (сложение списков).</span><br style="background-color: rgb(159, 197, 232);"><br style="background-color: rgb(159, 197, 232);"><span style="background-color: rgb(159, 197, 232);"></span><span style="background-color: rgb(159, 197, 232);"><span style="background-color: rgb(255, 255, 255);">% сложение списков</span><br></span>8 ?- append([a, b], [c, d, e], L).<br>L = [a, b, c, d, e].<br><br>% вычитание списков<br>9 ?- append(L1, [c, d, e], [a, b, c, d, e]).<br>L1 = [a, b] ;<br>false.<br><br>10 ?- append([a, b], L2, [a, b, c, d, e]).<br>L2 = [c, d, e].<br><br>% не возможно, поскольку массив [a, b, c, d, e] не начинается с [a, c]<br>11 ?- append([a, c], L2, [a, b, c, d, e]).<br>false.<br><br>% проверка на правильность сложения<br>13 ?- append("Привет ", "Мир", "Привет Мир").<br>true.<br><br>14 ?- append("Привет ", "Мир", "Привет Habrahabr").<br>false.<br><br>% даже перебор всех возможных вариантов сложения, дающих данный список<br>?- append(L1, L2, [a,b,c]).<br>L1 = [],<br>L2 = [a, b, c] ;<br>L1 = [a],<br>L2 = [b, c] ;<br>L1 = [a, b],<br>L2 = [c] ;<br>L1 = [a, b, c],<br>L2 = [] ;<br>false.<br><br>% и даже все возможные разбиения списка по некоторому элементу<br>?- B = [c,c,c,separator,d,d,separator,e,e,e,e], append(L1, [separator | L2], B).<br>B = [c, c, c, separator, d, d, separator, e, e|...],<br>L1 = [c, c, c],<br>L2 = [d, d, separator, e, e, e, e] ;<br>B = [c, c, c, separator, d, d, separator, e, e|...],<br>L1 = [c, c, c, separator, d, d],<br>L2 = [e, e, e, e] ;<br>false.<br><br>И все это используя только один предикат!<br><br>Чтобы подытожить, можно отметить что программа на прологе представляет собой одновременно базу данных (не реляционную, конечно, но допускающую практически любую функциональную зависимость) (факты) и инфраструктуру запросов к этой базе данных (предикаты), позволяющую построить по данным из базы данных новые отношения, зависимости, или получить некий результат, связанный с данными. (Впрочем, факты могут и отсутствовать)<br>При этом сами запросы (предикаты) способны иметь довольно замысловатую логику или даже выполнять вычислительные задачи. Чтобы окончательно повергнуть читателя, добавим, что предикаты способны динамически порождать факты и даже другие предикаты. Отличие от, вероятно, знакомой читателю императивной парадигмы программирования - в декларативной сущности получаемых программ.<br>Обратная сторона подобной гибкости концепции, разумеется, скорость (о чем справедливо указывали коментаторы предыдущего поста по прологу, впрочем коммерческие реализации пролога обладают довольно недурной производительностью). <br>Однако соблазнительная сторона такого подхода - возможность чрезвычайно выразительного (пусть, возможно, и не быстрого) решения на прологе задач символьных вычислений, парсинга текста и сложных структур данных (в т.ч. по грамматикам), задачах поиска, экспертных системах, задачах искуственного интеллекта. <br><br>Как-то гуляя по просторам сайта рефал-сообщества (еще один интересный язык программирования, местами идейно перекликающийся с прологом), наткнулся на сравнение Refal'а с Java'ой на примере решения конкретной задачи <a title="http://wiki.botik.ru/Refaldevel/ForJavaProgrammer" href="http://wiki.botik.ru/Refaldevel/ForJavaProgrammer" id="kiny">http://wiki.botik.ru/Refaldevel/ForJavaProgrammer</a> (собственно первоисточник - тут <a title="http://nuclight.livejournal.com/111696.html" href="http://nuclight.livejournal.com/111696.html" id="l7cz">http://nuclight.livejournal.com/111696.html</a> ). Для интереса написал решение на прологе (написание заняло ~10 мин).<br><br><span style="background-color: rgb(255, 153, 0);"></span><br>ischar(H, [H]).<br><br>% пустые строка соответстует пустому паттерну.<br>matches([], []) :-!.<br><br>% если равны первый знак патерна и строки, или первый знак паттерна "?"<br>% то для соответствия должны соответствовать "хвосты" строки и паттерна<br>matches([H | T], [H1 | T1]) :-<br><div style="margin-left: 40px;">	(&nbsp;&nbsp; <br></div><div style="margin-left: 40px;"><div style="margin-left: 40px;">	H = H1;<br>	ischar(H, "?")<br></div>	),<br>	matches(T, T1), !.<br></div><br><div>matches([H | T], T1) :-<br><div style="margin-left: 40px;">	ischar(H, "*"), % иначе, если первая буква паттерна * то<br>	append(_, T2, T1), % некая подстрока T2 хвоста строки T1 <br>	matches(T, T2), !. % должна соответствовать хвосту паттерна<br></div><br><br>и проверка (остальные тест-кейсы опустил из-за того, что очень длинные строки распирают страницу сайта)<br><br>check:-<br><div style="margin-left: 40px;">	matches("ASDFAASDASDAAASDASDASD", "ASDFAASDASDAAASDASDASD"),<br>	matches("*", "ASDFAASDASDAAASDASDASD"),<br>	matches("A?DF?A*ASD*ASDA?DASD", "ASDFAASDASDAAASDASDASD"),<br>	\+ matches("ASDFAASDADAAASDASDASD", "ASDFAASASDAAASDASDASD").<br></div><br>Запускаем проверку:<br><br>?- check.<br>true. % алгоритм работает верно на тестовых данных<br><br>Полный текст программ доступен [здесь].<br><br>И последнее, рекомендации и подсказки.<br><br>1) Все примеры приведены для диалеката SWI-Prolog (по моему скромному мнению - самый вменяемый и близкий к классическому прологу). Правда, рекомендую использовать версию 5.7.3 (бета) доступную здесь http://prolog.cs.vu.nl/download/devel/bin/ (файл w32pl573.exe для win) или 5.6.X. В версии 5.7.4 присутствует небольшая ошибка при работе в пролог-консоли (https://mailbox.iai.uni-bonn.de/mailman/public/swi-prolog/2009/000904.html).<br>2) Загрузка файла:<br>?- [file].<br>нескольких файлов:<br>?- [file1, file2, file3].<br>3) Хелп по предикату:<br>?- help(is).<br>или<br>?- apropos(test).<br>4) редактирование текущего загруженного файла (удобный редактор с подсветкой, к слову, написанный на прологе).<br>?- edit.<br>редактировать другой файл<br>?- edit(file).<br>5) Пошаговая отладка (консольная):<br>?- trace, do_smth_with(arg).<br>графическая:<br>?- gtrace, do_smth_with(arg).<br><br>На сегодня, все. Спасибо, что дочитали =).